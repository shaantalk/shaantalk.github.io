"use strict";(globalThis.webpackChunksantanu_dev=globalThis.webpackChunksantanu_dev||[]).push([[5607],{2808(e,r,n){n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var l=n(97),i=n(4848),s=n(8453);const o={slug:"JavaScript Promise.All Polyfill",title:"Custom Implementation of Promise.all in JavaScript",authors:"shaantalk",tags:["Promise","All","Polyfill. Promise.All"],keywords:["JavaScript Promise.All Polyfill"],description:"JavaScript Promise.All Polyfill"},t="Custom Implementation of Promise.all in JavaScript",a={authorsImageUrls:[void 0]},c=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Explanation",id:"explanation",level:2}];function m(e){const r={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"Promise.all"})," is a built-in JavaScript function that takes an array of Promises and resolves when all of them are fulfilled. If any Promise is rejected, it immediately rejects. Here, we implement our own version, ",(0,i.jsx)(r.code,{children:"Promise.myAll"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'Promise.myAll = (promises) => {\r\n  let responses = [];\r\n  let errorResp = [];\r\n  return new Promise((resolve, reject) => {\r\n    /** Loop over promises array **/\r\n    promises.forEach(async (singlePromise, i) => {\r\n      try {\r\n        /** wait for resolving 1 promise **/\r\n        let res = await singlePromise;\r\n        responses.push(res);\r\n        if (i == promises.length - 1) {\r\n          if (errorResp.length > 0) {\r\n            reject(errorResp);\r\n          } else {\r\n            resolve(responses)\r\n          }\r\n        }\r\n      } catch (err) {\r\n        errorResp.push(err);\r\n        reject(err);\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nlet p1 = Promise.resolve("Promise1 resolved");\r\n\r\nlet p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve("Promise 2 resolved after 2 seconds");\r\n  }, 1000);\r\n});\r\n\r\nlet p3 = Promise.resolve("Promise3 resolved");\r\n\r\nlet p4 = Promise.reject("Promise4 reject");\r\n\r\nPromise.myAll([p1, p2, p3]).then(\r\n  (res) => {\r\n    console.log("Response :", res);\r\n  },\r\n  (err) => {\r\n    console.log("error :", err);\r\n  }\r\n);\n'})}),"\n",(0,i.jsx)(r.h2,{id:"explanation",children:"Explanation"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Handling Multiple Promises:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"The function loops through the array of Promises."}),"\n",(0,i.jsxs)(r.li,{children:["Each Promise is awaited before being added to ",(0,i.jsx)(r.code,{children:"responses"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Error Handling:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["If any Promise fails, it gets pushed to ",(0,i.jsx)(r.code,{children:"errorResp"})," and the ",(0,i.jsx)(r.code,{children:"reject"})," function is called."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Resolving the Promises:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"If all Promises resolve successfully, the function resolves with the array of results."}),"\n",(0,i.jsx)(r.li,{children:"If any Promise rejects, it rejects immediately."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["This implementation mimics ",(0,i.jsx)(r.code,{children:"Promise.all"})," behavior but has a minor issue: it doesn\u2019t wait for all Promises to finish before rejecting. This can be improved by tracking completion count. \ud83d\ude80"]})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453(e,r,n){n.d(r,{R:()=>o,x:()=>t});var l=n(6540);const i={},s=l.createContext(i);function o(e){const r=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function t(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),l.createElement(s.Provider,{value:r},e.children)}},97(e){e.exports=JSON.parse('{"permalink":"/blog/JavaScript Promise.All Polyfill","source":"@site/blog/2025-03-23-JS-Promise-All-Polyfill/index.md","title":"Custom Implementation of Promise.all in JavaScript","description":"JavaScript Promise.All Polyfill","date":"2025-03-23T00:00:00.000Z","tags":[{"inline":true,"label":"Promise","permalink":"/blog/tags/promise"},{"inline":true,"label":"All","permalink":"/blog/tags/all"},{"inline":true,"label":"Polyfill. Promise.All","permalink":"/blog/tags/polyfill-promise-all"}],"readingTime":1.12,"hasTruncateMarker":false,"authors":[{"name":"Santanu Panda","title":"Cloud Engineer @ Cisco","url":"https://github.com/shaantalk","imageURL":"img/santanu.jpg","key":"shaantalk","page":null}],"frontMatter":{"slug":"JavaScript Promise.All Polyfill","title":"Custom Implementation of Promise.all in JavaScript","authors":"shaantalk","tags":["Promise","All","Polyfill. Promise.All"],"keywords":["JavaScript Promise.All Polyfill"],"description":"JavaScript Promise.All Polyfill"},"unlisted":false,"prevItem":{"title":"How to setTimeout Synchronously in JavaScript","permalink":"/blog/JavaScript Synchronous setTimeout"},"nextItem":{"title":"Understanding Object.preventExtensions, Object.seal, and Object.freeze in JavaScript","permalink":"/blog/JavaScript Object Modifications"}}')}}]);